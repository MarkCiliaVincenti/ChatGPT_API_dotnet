using OpenAI.Models.ChatCompletion;

namespace OpenAI.ChatGpt.Extensions;

public static class TestsGeneratorExtension
{
    public static async Task<string> GenerateTestsForCodeInFolder(
        this OpenAiClient client, 
        string directoryPath,
        string language = "C#",
        string framework = "xunit",
        string model = ChatCompletionModels.Default,
        bool excludeAutoGeneratedFiles = true,
        CancellationToken cancellationToken = default)
    {
        if (client == null) throw new ArgumentNullException(nameof(client));
        if (directoryPath == null) throw new ArgumentNullException(nameof(directoryPath));
        if (language == null) throw new ArgumentNullException(nameof(language));
        if (framework == null) throw new ArgumentNullException(nameof(framework));
        if (model == null) throw new ArgumentNullException(nameof(model));
        if (!Directory.Exists(directoryPath))
        {
            throw new ArgumentException($"Directory {directoryPath} does not exist");
        }
         
        var code = ReadCode(directoryPath, excludeAutoGeneratedFiles);
        var result = await client.GenerateTestsForCode(code, language, framework, model, cancellationToken);
        return result;
    }

    public static async Task<string> GenerateTestsForCode(
        this OpenAiClient client,
        string code, 
        string language = "C#",
        string framework = "xunit",
        string model = ChatCompletionModels.Default,
        CancellationToken cancellationToken = default)
    {
        if (client == null) throw new ArgumentNullException(nameof(client));
        if (code == null) throw new ArgumentNullException(nameof(code));
        if (language == null) throw new ArgumentNullException(nameof(language));
        if (framework == null) throw new ArgumentNullException(nameof(framework));
        if (model == null) throw new ArgumentNullException(nameof(model));
        var lengthLimit = ChatCompletionModels.MaxTokensForModel(model);
        if (code.Length > lengthLimit)
        {
            throw new InvalidOperationException($"Code is too long. Max length is {lengthLimit}");
        }

        var dialog = Dialog.StartAsSystem(
            "You are a test generator assistant. The user send the whole program code " +
            $"and you generate tests on {language} using {framework}" +
            "with > 90% coverage for given files. In your answers write ONLY the code.")
            .ThenUser(code);
        
        var result = await client.GetChatCompletions(
            dialog,
            model: model,
            maxTokens: lengthLimit - dialog.GetTotalLength(),
            cancellationToken: cancellationToken
        );
        
        return result;
    }

    private static string ReadCode(string directoryPath, bool excludeAutoGeneratedFiles)
    {
        var files = Directory.GetFiles(directoryPath, "*.cs", SearchOption.AllDirectories);
        var filesAndContent = files.Select(file => (file, code: File.ReadAllText(file)));
        if (excludeAutoGeneratedFiles)
        {
            filesAndContent = filesAndContent.Where(tuple  =>
            {
                return !tuple.code.Contains("<auto-generated") && !tuple.code.Contains("<autogenerated");
            });
        }
        var codeWithFileNames = filesAndContent.Select(tuple =>
        {
            var header = $"// File: {Path.GetFileName(tuple.file)}";
            return header + Environment.NewLine + tuple.code
                   + Environment.NewLine + Environment.NewLine;
        });
        var code = string.Join(Environment.NewLine, codeWithFileNames);
        return code;
    }
}

// var allLines = files.SelectMany(File.ReadAllLines).ToList();
// var usings = allLines.Where(l => l.StartsWith("using")).Distinct();
// var code = allLines.Where(l => !l.StartsWith("using"));
// var codeWithUsings = usings.Append(Environment.NewLine).Concat(code);