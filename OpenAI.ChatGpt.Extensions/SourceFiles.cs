using System.Collections;
using System.Collections.Concurrent;
using CSharpMinifier;

namespace OpenAI.ChatGpt.Extensions;

public class SourceFiles : IEnumerable<SourceFiles.SourceFile>
{
    private IEnumerable<SourceFile> _sources;

    public SourceFiles(IEnumerable<SourceFile> sources)
    {
        _sources = sources ?? throw new ArgumentNullException(nameof(sources));
    }

    public static SourceFiles ReadFilesFromDirectory(string directoryPath)
    {
        var files = Directory.GetFiles(directoryPath, "*.cs", SearchOption.AllDirectories);
        return new SourceFiles(files.Select(
            file => new SourceFile(file, File.ReadAllText(file)))
        );
    }
    
    public static async Task<SourceFiles> ReadFilesFromDirectoryAsyncInParallel(
        string directoryPath, int? degreeOfParallelism = null, CancellationToken cancellationToken = default)
    {
        degreeOfParallelism ??= Environment.ProcessorCount / 2;
        var files = Directory.GetFiles(directoryPath, "*.cs", SearchOption.AllDirectories);
        var sourceFiles = new ConcurrentBag<SourceFile>();

        var options = new ParallelOptions()
        {
            MaxDegreeOfParallelism = degreeOfParallelism.Value, 
            CancellationToken = cancellationToken
        };
        await Parallel.ForEachAsync(files, options,
            async (file, _) =>
        {
            var content = await File.ReadAllTextAsync(file, _);
            sourceFiles.Add(new SourceFile(file, content));
        });
        
        return new SourceFiles(sourceFiles);
    }

    public void MakeList()
    {
        _sources = _sources.ToList();
    }

    public void Filter(
        bool excludeAutoGeneratedFiles, 
        bool removeConfigureAwait, 
        bool minify)
    {
        if (excludeAutoGeneratedFiles)
        {
            ExcludeAutoGeneratedFiles();
        }

        if (minify)
        {
            Minify();
        }

        if (removeConfigureAwait)
        {
            RemoveConfigureAwait();
        }
    }

    public void RemoveConfigureAwait()
    {
        _sources = _sources.Select(file
            => file with { Code = file.Code.Replace(".ConfigureAwait(false)", "") });
    }

    public void Minify()
    {
        // TODO join all usings to one, regex: ^\s*(using\s+[a-zA-Z0-9_.]+)\s*;\s*
        _sources = _sources.Select(file
            => file with { Code = string.Join(' ', Minifier.Minify(file.Code)) });
    }

    public void ExcludeAutoGeneratedFiles()
    {
        _sources = _sources.Where(file => !file.IsAutoGenerated());
    }

    public string GetCode()
    {
        var codeWithFileNames = _sources.Select(file =>
        {
            var header = $"// File: {Path.GetFileName(file.FileName)}";
            return header + Environment.NewLine + file.Code
                   + Environment.NewLine + Environment.NewLine;
        });
        var code = string.Join(Environment.NewLine, codeWithFileNames);
        return code;
    }

    public IEnumerator<SourceFile> GetEnumerator() => _sources.GetEnumerator();

    IEnumerator IEnumerable.GetEnumerator() => GetEnumerator();
        
    public record SourceFile(string FileName, string Code)
    {
        public string Code { get; set; } = Code;

        public bool IsAutoGenerated()
        {
            return Code.Contains("<auto-generated") || Code.Contains("<autogenerated");
        }
    }

    public void ExcludeMigrationFiles()
    {
        _sources = _sources.Where(file 
            => !file.FileName.Split(Path.DirectorySeparatorChar).Contains("Migrations"));
    }

    public static SourceFiles FromText(string input)
    {
        return new SourceFiles(new[] { new SourceFile("Program.cs", input) });
    }
}